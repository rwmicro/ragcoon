import { ChromaClient, Collection, OpenAIEmbeddingFunction } from 'chromadb'
import { DocumentChunk, QueryResult } from './types'

const COLLECTION_NAME = 'ragcoon_documents'

/**
 * Client ChromaDB singleton
 */
let chromaClient: ChromaClient | null = null

export function getChromaClient(): ChromaClient {
  if (!chromaClient) {
    const chromaUrl = process.env.CHROMA_URL || 'http://localhost:8000'
    chromaClient = new ChromaClient({ path: chromaUrl })
  }
  return chromaClient
}

/**
 * Custom embedding function that indicates we provide our own embeddings
 * This is a dummy function since we create embeddings via Ollama before storing
 */
class CustomEmbeddingFunction {
  async generate(texts: string[]): Promise<number[][]> {
    // This should never be called since we provide embeddings directly
    // But ChromaDB requires an embedding function to be specified
    throw new Error('Embeddings should be provided directly, not generated by ChromaDB')
  }
}

/**
 * Obtient ou crée la collection ChromaDB
 */
export async function getOrCreateCollection(): Promise<Collection> {
  const client = getChromaClient()

  try {
    // Create collection with custom embedding function
    // We provide embeddings ourselves via Ollama, so this is just a placeholder
    const collection = await client.getOrCreateCollection({
      name: COLLECTION_NAME,
      embeddingFunction: new CustomEmbeddingFunction(),
      metadata: {
        description: 'RAGCoon document embeddings',
        'hnsw:space': 'cosine',
      },
    })

    return collection
  } catch (error) {
    console.error('Error getting or creating collection:', error)
    throw error
  }
}

/**
 * Ajoute des chunks à la collection
 */
export async function addChunks(chunks: DocumentChunk[]): Promise<void> {
  if (chunks.length === 0) {
    return
  }

  const collection = await getOrCreateCollection()

  // Préparer les données pour ChromaDB
  const ids = chunks.map((c) => c.id)
  const embeddings = chunks.map((c) => {
    if (!c.embedding) {
      throw new Error(`Chunk ${c.id} has no embedding`)
    }
    return c.embedding
  })
  const documents = chunks.map((c) => c.content)
  const metadatas = chunks.map((c) => ({
    source: c.metadata.source,
    filename: c.metadata.filename,
    fileType: c.metadata.fileType,
    chunkIndex: c.metadata.chunkIndex,
    totalChunks: c.metadata.totalChunks,
    pageNumber: c.metadata.pageNumber || 0,
    title: c.metadata.title || '',
    createdAt: c.metadata.createdAt,
  }))

  try {
    await collection.add({
      ids,
      embeddings,
      documents,
      metadatas,
    })

    console.log(`Added ${chunks.length} chunks to ChromaDB`)
  } catch (error) {
    console.error('Error adding chunks to ChromaDB:', error)
    throw error
  }
}

/**
 * Recherche les chunks les plus similaires
 */
export async function queryChunks(
  queryEmbedding: number[],
  limit: number = 5
): Promise<QueryResult[]> {
  const collection = await getOrCreateCollection()

  try {
    const results = await collection.query({
      queryEmbeddings: [queryEmbedding],
      nResults: limit,
    })

    if (!results.ids || !results.ids[0] || results.ids[0].length === 0) {
      return []
    }

    // Convertir les résultats ChromaDB en QueryResult
    const queryResults: QueryResult[] = []

    for (let i = 0; i < results.ids[0].length; i++) {
      const id = results.ids[0][i]
      const document = results.documents[0]?.[i]
      const metadata = results.metadatas[0]?.[i]
      const distance = results.distances?.[0]?.[i] || 0

      if (!document || !metadata) {
        continue
      }

      queryResults.push({
        chunk: {
          id,
          content: document,
          metadata: {
            source: metadata.source as string,
            filename: metadata.filename as string,
            fileType: metadata.fileType as 'md' | 'pdf',
            chunkIndex: metadata.chunkIndex as number,
            totalChunks: metadata.totalChunks as number,
            pageNumber: metadata.pageNumber as number | undefined,
            title: metadata.title as string | undefined,
            createdAt: metadata.createdAt as string,
          },
        },
        score: 1 - distance, // Convertir distance en score
        distance,
      })
    }

    return queryResults
  } catch (error) {
    console.error('Error querying ChromaDB:', error)
    throw error
  }
}

/**
 * Supprime tous les chunks d'un fichier
 */
export async function deleteChunksByFilename(filename: string): Promise<void> {
  const collection = await getOrCreateCollection()

  try {
    await collection.delete({
      where: { filename },
    })

    console.log(`Deleted chunks for file: ${filename}`)
  } catch (error) {
    console.error('Error deleting chunks:', error)
    throw error
  }
}

/**
 * Compte le nombre total de chunks dans la collection
 */
export async function getChunksCount(): Promise<number> {
  const collection = await getOrCreateCollection()

  try {
    const count = await collection.count()
    return count
  } catch (error) {
    console.error('Error counting chunks:', error)
    return 0
  }
}

/**
 * Supprime toute la collection (pour reset)
 */
export async function deleteCollection(): Promise<void> {
  const client = getChromaClient()

  try {
    await client.deleteCollection({ name: COLLECTION_NAME })
    console.log('Collection deleted')
  } catch (error) {
    console.error('Error deleting collection:', error)
    throw error
  }
}
