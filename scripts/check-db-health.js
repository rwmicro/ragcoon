#!/usr/bin/env node\n\n/**\n * Database Health Check Script\n * Run this to diagnose SQLite database issues\n */\n\nconst { getDatabase, getDatabaseHealth, closeDatabase } = require('../lib/sqlite/connection')\nconst { memoryManager } = require('../lib/memory-manager')\nconst fs = require('fs')\nconst path = require('path')\n\nfunction formatBytes(bytes) {\n  return (bytes / 1024 / 1024).toFixed(2) + ' MB'\n}\n\nfunction checkEnvironment() {\n  console.log('üîç Environment Check:')\n  console.log(`  Node.js Version: ${process.version}`)\n  console.log(`  Platform: ${process.platform} ${process.arch}`)\n  console.log(`  Memory Limit: ${process.env.NODE_OPTIONS || 'default'}`)\n  console.log(`  GC Available: ${global.gc ? 'Yes' : 'No (run with --expose-gc)'}`)\n  console.log()\n}\n\nfunction checkDatabaseFiles() {\n  console.log('üìÅ Database Files:')\n  const dbPath = process.env.SQLITE_DB_PATH || path.join(process.cwd(), 'data', 'ragcoon.db')\n  const dataDir = path.dirname(dbPath)\n  \n  if (!fs.existsSync(dataDir)) {\n    console.log(`  ‚ùå Data directory does not exist: ${dataDir}`)\n    return false\n  }\n  \n  console.log(`  üìÇ Data directory: ${dataDir}`)\n  \n  const files = fs.readdirSync(dataDir)\n  files.forEach(file => {\n    const filePath = path.join(dataDir, file)\n    const stats = fs.statSync(filePath)\n    console.log(`  üìÑ ${file}: ${formatBytes(stats.size)}`)\n  })\n  \n  return fs.existsSync(dbPath)\n}\n\nfunction checkMemory() {\n  console.log('üß† Memory Status:')\n  const stats = memoryManager.getMemoryStats()\n  const pressure = memoryManager.checkMemoryPressure()\n  \n  console.log(`  Heap Used: ${stats.heapUsed.toFixed(2)} MB`)\n  console.log(`  Heap Total: ${stats.heapTotal.toFixed(2)} MB`)\n  console.log(`  External: ${stats.external.toFixed(2)} MB`)\n  console.log(`  RSS: ${stats.rss.toFixed(2)} MB`)\n  console.log(`  Pressure: ${pressure}`)\n  \n  const recommendations = memoryManager.getMemoryRecommendations()\n  if (recommendations.length > 0) {\n    console.log('  üí° Recommendations:')\n    recommendations.forEach(rec => console.log(`    - ${rec}`))\n  }\n  console.log()\n}\n\nasync function checkDatabaseConnection() {\n  console.log('üîó Database Connection:')\n  \n  try {\n    const db = getDatabase()\n    console.log('  ‚úÖ Connection established')\n    \n    // Test basic query\n    const result = db.prepare('SELECT 1 as test').get()\n    console.log(`  ‚úÖ Basic query successful: ${JSON.stringify(result)}`)\n    \n    // Check health\n    const health = getDatabaseHealth()\n    if (health) {\n      console.log(`  üìä Health Check: ${health.connected ? 'Connected' : 'Disconnected'}`)\n      console.log(`  üìÇ Path: ${health.path}`)\n      console.log(`  üìè Size: ${formatBytes(health.size * 1024 * 1024)}`)\n      console.log(`  ‚úçÔ∏è  Writable: ${health.writable ? 'Yes' : 'No'}`)\n    }\n    \n    // Check migrations table\n    try {\n      const migrations = db.prepare('SELECT * FROM _migrations ORDER BY version DESC LIMIT 5').all()\n      if (migrations.length > 0) {\n        console.log(`  üìã Recent migrations (${migrations.length} found):`)\n        migrations.forEach(m => {\n          console.log(`    Version ${m.version}: ${m.completed_at} (${m.checksum})`)\n        })\n      } else {\n        console.log('  ‚ö†Ô∏è  No migration records found')\n      }\n    } catch (err) {\n      console.log('  ‚ö†Ô∏è  Migration table not found (database not initialized)')\n    }\n    \n    return true\n  } catch (error) {\n    console.log(`  ‚ùå Connection failed: ${error.message}`)\n    return false\n  } finally {\n    console.log()\n  }\n}\n\nasync function testPerformance() {\n  console.log('‚ö° Performance Test:')\n  \n  try {\n    const db = getDatabase()\n    const startTime = Date.now()\n    \n    // Create a test table and insert some data\n    db.exec(`\n      CREATE TEMPORARY TABLE test_performance (\n        id INTEGER PRIMARY KEY,\n        data TEXT,\n        created_at DATETIME DEFAULT CURRENT_TIMESTAMP\n      )\n    `)\n    \n    const insertStmt = db.prepare('INSERT INTO test_performance (data) VALUES (?)')\n    const transaction = db.transaction((rows) => {\n      for (const row of rows) {\n        insertStmt.run(row)\n      }\n    })\n    \n    // Insert 1000 test rows\n    const testData = Array.from({ length: 1000 }, (_, i) => `Test data ${i}`)\n    transaction(testData)\n    \n    const selectResult = db.prepare('SELECT COUNT(*) as count FROM test_performance').get()\n    const endTime = Date.now()\n    \n    console.log(`  ‚úÖ Inserted and counted ${selectResult.count} rows in ${endTime - startTime}ms`)\n    \n    // Test memory during operation\n    const memoryAfter = memoryManager.getMemoryStats()\n    console.log(`  üß† Memory after test: ${memoryAfter.heapUsed.toFixed(2)} MB`)\n    \n  } catch (error) {\n    console.log(`  ‚ùå Performance test failed: ${error.message}`)\n  }\n  \n  console.log()\n}\n\nasync function main() {\n  console.log('üè• SQLite Database Health Check\\n')\n  \n  checkEnvironment()\n  const dbFilesExist = checkDatabaseFiles()\n  checkMemory()\n  \n  if (dbFilesExist) {\n    const connectionOk = await checkDatabaseConnection()\n    if (connectionOk) {\n      await testPerformance()\n    }\n  } else {\n    console.log('‚ùå Database files not found - run the application first to initialize')\n  }\n  \n  closeDatabase()\n  \n  console.log('üèÅ Health check completed')\n}\n\nif (require.main === module) {\n  main().catch(console.error)\n}\n\nmodule.exports = { main }"